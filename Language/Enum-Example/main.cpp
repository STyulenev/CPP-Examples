#include "Example1.h"
#include "Example2.h"
#include "Example3.h"

/*
 * Перечисления (enum) используются для объявления набора именованных постоянных величин. Их основное назначение — повысить читаемость
 * и безопасность кода, заменяя магические числа осмысленными названиями.
 *
 * Есть два основных вида перечислений в C++:
 *
 * Классическое перечисление (enum)
 * Классическое перечисление появилось ещё в стандарте C++98 и обладает следующими характеристиками:
 * - Пространство имён: Константы объявляются непосредственно в глобальном пространстве имён (или области видимости класса, если
 * объявлено внутри класса).
 * - Нет строгих ограничений на тип элементов. Компилятор сам выбирает подходящий интегральный тип (обычно int).
 * - Преобразования: Легко преобразуется в базовые типы вроде int, что иногда приводит к ошибкам, связанным с неправильным использованием значений.
 *
 * Недостатки классических перечислений:
 * - Неявные преобразования между перечисляемыми значениями и базовыми типами могут привести к путанице и ошибкам.
 * - Отсутствие строгой типизации и изоляции пространства имён затрудняет написание надёжного и безопасного кода.
 *
 * Перечисление классов (enum class)
 * Перечисления классов (enum class) введены в стандарт C++11 для устранения недостатков классических перечислений.
 * Они обладают рядом преимуществ:
 * - Изоляция пространств имён: Константы видны только через квалифицированное имя (например, Color::RED).
 * - Четкая типизация: Каждое перечисление имеет уникальный тип, несовместимый с другими типами.
 * - Нет неявных преобразований: Нельзя неявно присвоить значение перечисления другому типу (нужно использовать явное приведение).
 * - Возможность задания точного базового типа: Можно явно определить тип, используемый для хранения значений перечисления.
 */

int main()
{
    {
        //Example1::test1();
        //Example1::test2();
        //Example1::test3();
        //Example1::test4();
    }

    {
        //Example2::test1();
        //Example2::test2();
    }

    {
        //Example3::Ex1::test();
        //Example3::Ex2::test();
        //Example3::Ex3::test();
        Example3::Ex4::test();
    }

    return 0;
}

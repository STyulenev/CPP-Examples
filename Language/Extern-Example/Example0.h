#pragma once

#include <iostream>

template <typename T>
void printType()
{
    std::cout << "Type: " << typeid(T).name() << std::endl;
}

/*
 * extern "C" делает имя функции в C++ связанным с C (компилятор не искажает имя), так что клиентский код C может ссылаться на
 * (использовать) функцию, используя совместимый с C заголовочный файл, содержащий только объявление вашей функции. Определение
 * вашей функции содержится в двоичном формате (который был скомпилирован вашим компилятором C++), с которым клиентский компоновщик
 * C затем свяжется, используя имя C.
 *
 * Поскольку в C++ есть перегрузка имен функций, а в C — нет, компилятор C++ не может просто использовать имя функции как уникальный
 * идентификатор для ссылки, поэтому он искажает имя, добавляя информацию об аргументах. Компилятору C не нужно искажать имя, поскольку
 * в C нельзя перегружать имена функций. Когда вы указываете, что функция имеет extern "C"связь в C++, компилятор C++ не добавляет
 * информацию о типе аргумента/параметра к имени, используемому для связи.
 */

// #ifdef __cplusplus
extern "C" {
// #endif

// #include "functions.c"
// ...

void functionFromCLibrary()
{
    // ...
}

// #ifdef __cplusplus
}
// #endif

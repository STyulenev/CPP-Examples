#pragma once

/*
 * inline и static, разница
 *
 *  inline (C++17 для переменных)
 * - Одно определение на программу (One Definition Rule - ODR)
 * - Может быть видна и использована в нескольких единицах трансляции
 * - Ссылается на один и тот же объект во всей программе
 *
 * static (для переменных в области пространства имен)
 * - Отдельная копия в каждой единице трансляции
 * - Каждый .cpp файл получает свою независимую копию
 * - Изолирована в пределах единицы трансляции
 *
 */

// ------------------------------- Обычные переменные -------------------------------

// STATIC - отдельная копия в каждом .cpp файле
static int static_counter = 0;
// Каждая единица трансляции видит СВОЮ копию

// INLINE - одна копия на всю программу
inline int inline_counter = 0;
// Все единицы трансляции видят ОДНУ И ТУ ЖЕ переменную

// -------------------------------      Функции       -------------------------------

// STATIC функция
static void static_func() {
    // Видна только в этой единице трансляции
    // Не может быть вызвана из других .cpp файлов
}

// INLINE функция
inline void inline_func() {
    // Видна везде, где подключен заголовочный файл
    // Одно определение на программу
    // Может быть встроена компилятором
}

// Обычная функция (без inline/static)
void regular_func(); // Должна быть определена только в одном .cpp файле

// ------------------------------- Поля/методы класса  -------------------------------

class MyClass {
    // 1. Статические поля класса (до C++17)
    static int traditional_static;  // Требует определения в .cpp файле

    // 2. Inline статические поля (C++17)
    static inline int inline_static = 42;  // Можно инициализировать в классе

    // 3. Нестатические inline поля (C++20)
    //inline int default_value = 100;  // Значение по умолчанию

    // 4. Статические функции
    static void static_method() {
        // Не имеет доступа к this
        // Может быть вызвана без экземпляра класса
    }

    // 5. Inline методы (неявно inline в классе)
    void method1() { // Автоматически inline при определении внутри класса
        // ...
    }

    void method2();
};

inline void MyClass::method2()
{
    // ...
}

// До C++17 нужно было определять так:
// int MyClass::traditional_static = 42;  // В .cpp файле

// -------------------------------      Константы      -------------------------------

// 1. Static константа (устаревший способ)
static const int MAX_SIZE = 100;  // Копия в каждом .cpp файле

// Но если обернуть struct/class:
struct Consts
{
    static constexpr int MAX_SIZE = 100; // Одна копия, вычисляется на этапе компиляции
};

// 2. Inline constexpr (современный способ, без struct/class)
inline constexpr int MAX_SIZE_INLINE = 100;  // Одна копия, вычисляется на этапе компиляции

// 3. Const в анонимном namespace (альтернатива static)
namespace {
    const int MAX_SIZE_ANON = 100;  // Только в этой единице трансляции
}

// ------------------------------- Static inline функции -------------------------------

// Редко используется, но возможно
static inline void helper() {
    // Внутреннее связывание + может быть встроена
    // Полезно для маленьких вспомогательных функций в заголовках
}

// ------------------------------- Static inline переменная ----------------------------

static inline int counter = 0;
// Это эквивалентно: static int counter = 0;  // Но с дополнительной гарантией ODR для inline

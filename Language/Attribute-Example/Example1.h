#pragma once

#include <iostream>

/*
 *
 *
 * - [[noreturn]] - Указывает, что функция не вернёт управление вызывающей функции после своего завершения (например, функциям,
 * которые завершают приложение, генерируют исключения, зацикливаются и т. д.). Этот атрибут применяется только к имени объявляемой функции
 * при её объявлении. Если функция, ранее объявленная с помощью [[noreturn]], вызывается и этот вызов в конечном итоге возвращает управление,
 * поведение является неопределенным во время выполнения.
 * - [[fallthrough]] - Оператор fallthrough может использоваться только в операторе switch , где следующим выполняемым оператором является
 * оператор с меткой case или default для этого оператора switch. Если оператор fallthrough находится внутри цикла, следующий (с меткой)
 * оператор должен быть частью той же итерации этого цикла.
 * - [[deprecated]] - Указывает, что использование имени или сущности, объявленной с этим атрибутом, разрешено, но не рекомендуется по
 * какой-либо причине. Компиляторы обычно выдают предупреждения при таком использовании. Строковый литерал, если он указан, обычно включается
 *  предупреждения.
 * - [[nodiscard]] - Если объявленная функция nodiscardили функция, возвращающая перечисление или класс, объявленный nodiscardпо значению,
 * вызывается из выражения с отброшенным значением, отличного от приведения к void, компилятору рекомендуется выдать предупреждение.
 * - [[maybe_unused]] - Подавляет предупреждения о неиспользуемых сущностях.
 * - [[no_unique_address]] - Применяется к имени, объявленному в объявлении нестатического члена данных, который не является битовым полем.
 * Делает этот член-подобъект потенциально перекрывающимся, то есть допускает перекрытие этого члена другими нестатическими членами данных
 * или подобъектами базового класса его класса. Это означает, что если член имеет пустой тип класса (например, распределитель без сохранения
 * состояния), компилятор может оптимизировать его так, чтобы он не занимал места, как если бы он был пустым базовым элементом. Если член не
 * пустой, любое заполнение хвоста в нём также может быть повторно использовано для хранения других членов данных.
 * - [[likely]] / [[unlikely]] - Разрешить компилятору оптимизировать случай, когда пути выполнения, включающие этот оператор, более или менее
 * вероятны, чем любой альтернативный путь выполнения, не включающий такой оператор.
 * - [[assume]] - Указывает, что предполагается, что данное выражение всегда оценивается какистинныйв заданной точке, чтобы позволить компилятору
 * оптимизировать работу на основе предоставленной информации.
 *
 *
 */

namespace Example1
{

// [[noreturn]] - без выхода из функции
[[noreturn]] void errorFunction(bool error)
{
    if (error)
        throw std::runtime_error("error");
    else
        std::terminate();
}


void test1()
{
    bool status = true;

    if (status)
    {
        // Тупиковый код
        errorFunction(true);
    }
}

// [[fallthrough]] - падение на case ниже
void test2()
{
    int input = 2;

    switch (input) {
    case 0:
        std::cout << "0" << std::endl;
        [[fallthrough]]; // > No warning
    case 1:
        std::cout << "1" << std::endl;
        // ...
        break;
    case 2:
        std::cout << "2" << std::endl;
        [[fallthrough]]; // > No warning
    case 4:
        std::cout << "4" << std::endl;
        // ...
        break;
    default:
        return;
    }
}

// [[deprecated]] - устаревшая функция
[[deprecated]]
void oldFunction1()
{
    std::cout << "oldFunction1()" << std::endl;
}

[[deprecated("This is old Function. Dont use it")]]
void oldFunction2()
{
    std::cout << "oldFunction2()" << std::endl;
}

void test3()
{
    oldFunction1();
    oldFunction2();
}

// [[nodiscard]] - обязательное использование возвращаемого значения
[[nodiscard]] bool getStatus()
{
    return true;
}

void test4()
{
    getStatus();
}

// [[maybe_unused]]
void doTask([[maybe_unused]] int count = 0)
{
    [[maybe_unused]] bool status = 0;

    // ...
}

void test5()
{
    doTask();
}

// [[no_unique_address]] - оптимизация размера класса
struct Empty
{
    // static ...
};

struct SomeClass
{
    [[no_unique_address]] Empty e; // Не занимает место в памяти
    int x;
    // ...
};

void test6()
{
    SomeClass sc;
    std::cout << "size: " << sizeof(sc) << std::endl; // 4, без аттрибута 8
}

// [[likely]] / [[unlikely]] - более/менее вероятные случаи ветвления
void test7()
{
    int i = 2;

    switch (i)
    {
    case 1: [[fallthrough]];
    [[likely]] case 2:
        // ...
        break;
    [[unlikely]] default:
        // ...
        break;
    }

    if (i == 2) [[likely]]
    {
        // ...
    }
    else [[unlikely]]
    {
        // ...
    }
}

// [[assume]] - передача предположений компилятору
void test8()
{
    int x = 10;
    [[assume(x > 0)]]; // Компилятор может оптимизировать код
    std::cout << 100 / x; // Не будет проверки деления на 0
}

} // namespace Example1

#pragma once

#include <iostream>
#include <memory>

/*
 * Проблемы при использовании умных указателей
 *
 * - Циклические ссылки. Возникают, когда два класса напрямую или косвенно ссылаются друг на друга с помощью умных указателей.
 * При попытке удалить один из классов произойдёт зацикливание. Умные указатели не решают эту проблему, ответственность лежит на программисте.
 * - Совместное использование обычных и умных указателей. Переход от умного указателя к обычному нарушает контракт владения умного
 * указателя, он уже не контролирует экземпляр объекта. Это может привести к ошибке доступа к памяти, так как объект будет удалён дважды.
 * - Утечка памяти. Возникает, когда указатель не владеет объектом, на который ссылается. Из-за этого нужно внимательно относиться к
 * уничтожению объекта, иначе возможны утечки памяти.
 * - Проблемы с внезапными исключениями. Если на стеке был создан объект, а после этого было выброшено исключение, C++ гарантированно
 * вызовет деструктор для этого объекта.
 * - Ситуация, когда счётчик ссылок для общего указателя равен нулю, но блок не может быть освобождён. Это происходит, когда есть слабые ссылки.
 */
namespace Example1 {

struct B;

struct A
{
    std::shared_ptr<B> b_ptr;

    ~A() {
        std::cout << "A::~A()" << std::endl;
    }
};

struct B
{
    std::shared_ptr<A> a_ptr;

    ~B() {
        std::cout << "B::~B()" << std::endl;
    }
};

struct C
{
    C() {
        std::cout << "C::C()" << std::endl;

        throw 5;
    }

    ~C() {
        std::cout << "C::~C()" << std::endl;
    }

    void print() {
        std::cout << "C::print()" << std::endl;
    }
};

/*
 * Циклические ссылки
 */
void test1()
{
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();

    a->b_ptr = b;
    b->a_ptr = a;

    // Утечка памяти
}

/*
 * Если объект создается с new, а затем передается в shared_ptr вручную, можно случайно получить двойное удаление или утечку памяти.
 */
void test2()
{
    A* a = new A();
    std::shared_ptr<A> p1(a);
    std::shared_ptr<A> p2(a); // Ошибка! Два shared_ptr управляют одним указателем

    // Два раза вызывается деструктор или утечка памяти (UB)
}

/*
 * Сырые указатели + передача прав к shared_ptr. Следует использовать только умные указатели.
 */
void test3()
{
    A* a = nullptr;
    std::shared_ptr<A> p1(a);

    {
        A* a2 = new A();
        a = a2;

        //p1.reset(a2);

        delete a2;
    }

    delete a; // Два раза вызывается деструктор и аварийное завершение
}

/*
 * Передача `shared_ptr` по значению. Если передавать shared_ptr в функцию по значению, создается лишний временный shared_ptr,
 * что может привести к неожиданному поведению.
 */
void test4()
{
    std::shared_ptr<A> a = std::make_shared<A>();

    auto lambda1 = [](std::shared_ptr<A> a) {
        std::cout << "lambda1::count = " << a.use_count() << std::endl;
    };

    auto lambda2 = [](const std::shared_ptr<A>& a) {
        std::cout << "lambda2::count = " << a.use_count() << std::endl;
    };

    std::cout << "count = " << a.use_count() << std::endl;

    lambda1(a);
    lambda2(a);
}

/*
 * Исключение в конструкторе. Умные указатели в C++ полезны в ситуации, когда конструктор генерирует исключения.
 * Это связано с тем, что если конструктор не завершит работу, объект не будет создан, и для не полностью сконструированных
 * объектов не будет вызван деструктор. Из-за этого могут возникать утечки памяти.
 */
void test5()
{
    std::shared_ptr<C> p1;

    try {
        p1.reset(new C());
    } catch (...) {
        // ...
    }

    try {
        p1 = std::make_shared<C>();
    } catch (...) {
        // ...
    }

    auto lambda1 = [](std::shared_ptr<C> c) {
        std::cout << "lambda1::count = " << c.use_count() << std::endl; // lambda1::count = 0
    };

    // Может сработать, но это UB
    p1->print();

    lambda1(p1);
}

/*
 * Неопределенное поведение порядка вычисления аргументов (unspecified evaluation order).
 */
void test6()
{
    std::shared_ptr<A> a = std::make_shared<A>();

    auto lambda1 = [](std::shared_ptr<A> a, std::shared_ptr<C> c) {};

    // Здесь не будет корректного освобождения ресурсов
    try {
        lambda1(std::shared_ptr<A>(new A()), std::shared_ptr<C>(new C()));
    } catch (...) {
        // ...
    }

    std::cout << std::endl;

    // Здесь будет корректное освобождения ресурсов
    try {
        lambda1(std::make_shared<A>(), std::make_shared<C>());
    } catch (...) {
        // ...
    }
}

} // namespace Example1

# C++ Идиомы

* Attorney-Client  
Идиома "Адвокат-Клиент" позволяет классу точно контролировать объем доступа, которые он предоставляет своим классам-друзьям через friend.

* Capability Query  
Идиома "Запрос возможностей" может использоваться для проверки поддержки интерфейса во время выполнения программы.
```cpp
if (IFirst* iFirst = dynamic_cast<IFirst*>(concreteClass)) { // Capability Query
    // ...
}
```

* Copy-and-Swap  
Идиома "копирования и замены" используется для упрощения операции присваивания через "operator=" и обеспечивает устойчивость к исключениям.

* Copy-on-Write (COW)  
Идиома "копирование при записи" используется для управления ресурсами и позволяет откладывать копирование объекта до его изменения.

* Curiously Recurring Template Pattern (CRTP)  
Идиома/паттерн "Странно рекурсивный шаблон" позволяет обойтись без виртуальных функций для вызова метода у наследника, что позволяет получить выигрышь во времени.

* Calling Virtuals During Initialization (CVDI)  
Идиома "Вызов виртуальных методов во время инициализации" - позволяет обойти запрет языка на вызов виртуальных методов во время инициализации объектов путём создания шаблонного класса фабрики с созданием объекта, вызывом виртуального метода и возвратом объекта.
```cpp
template<class ClassType, class Parameter>
std::unique_ptr<AbstractBase> factory(Parameter parameter)
{
    std::unique_ptr<AbstractBase> uptr = std::make_unique<ClassType>(parameter);
    uptr->initialization();
    return uptr;
}
```

* Detection idiom  
Идиома обнаружения — это идиома, которая позволяет проводить проверку типов во время компиляции в C++. Используя идиому обнаружения, можно проверить, есть ли у типа методы, псевдонимы типов или члены, которые соответствуют определенному интерфейсу.

* Immediately-Invoked Function Expression (IIFE)  
Идиома "немедленно вызываемого функциональное выражение" представляет собой лямбда-выражение, которое немедленно вызывается. Определяется как:
```cpp
[]{ ... }();
```

* Move-and-Swap  
Идиома "перемещение с обменом" применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора копирования.

* Named Constructor  
Идиома именованного конструктора использует набор статических функций-членов с осмысленными именами для создания объектов вместо конструкторов. Конструкторы являются либо закрытыми, либо защищенными, и клиенты имеют доступ только к публичным статическим функциям.

* Non-Virtual Interface (NVI)  
Идиома "Невиртуальный интерфейс" - идиома C++ в которой открытый интерфейс класса не должен содержать виртуальных функций. Все виртуальные функции делаются закрытыми (максимум защищенными) и вызываются внутри открытых невиртуальных.

* Pointer to Implementation (PIMPLE)  
Идиома "Указатель на реализацию" применяется для скрытия от пользователя деталей реализации класса в единице трансляции (*.cpp) через указатель в заголовочном файле.
```cpp
class AnotherClass;
```

* Resource Acquisition is Initialization (RAII)  
Идиома "захват ресурса должен быть инициализацией объекта" используемая для управления ресурсами. Она обеспечивает автоматическое освобождение ресурсов при выходе из области видимости объекта, которому эти ресурсы принадлежат.

* Reference counting  
Идиома/техника "подсчёт ссылок" используется для управления памятью, при которой объекты отслеживают, сколько на них ссылок. Когда счёт достигает нуля, объект удаляется.

* Remove-erase  
Идиома "Удалить-стереть" используется для удаления элементов из контейнера и предполагает применение алгоритма remove() или remove_if(), за которым следует вызов функции erase() контейнера. Это особенно эффективно при работе с std::vector.

* Return Type Resolver  
Идиома "Разрешитель типа возвращаемого значения" позволяет функции определять свой возвращаемый тип на основе контекста вызова. Это достигается с помощью шаблонов и вывода типов.

* Thin Template  
Идиома "Тонкого шаблона" используется для сокращения дублирования объектного кода, например, в абстрактном классе/интерфейсе контейнеров.
```cpp
virtual void* at(int _index) = 0;
```

* Virtual сonstructor  
Идиома "Виртуального конструктора" предполагает создание виртуальных методов класса, которые могут использоваться как виртуальный конструктор т.к. создание виртуального конструктора в C++ запрещено.
```cpp
virtual AbstractTarget* create() const = 0;
virtual AbstractTarget* clone() const = 0;
```


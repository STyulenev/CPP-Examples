#include <thread>
#include <vector>

#include "Singletons.h"

/*
 * Double-Checked Locking (шаблон проектирования «блокировка с двойной проверкой») — подход, который используется для
 * уменьшения накладных расходов, связанных с получением блокировки, при реализации ленивой инициализации в многопоточных
 * программах, например в составе шаблона проектирования «Одиночка».
 * Название связано с тем, что условие блокировки проверяется дважды: сначала перед блокировкой, а потом сразу после.
 *
 * Шаблон описывает последовательность действий:
 * - Проверка условия: проинициализирован объект или нет. Если да, сразу вернуть ссылку на объект.
 * - Взятие блокировки.
 * - Повторная проверка условия: если объект проинициализирован, снять блокировку и вернуть ссылку. Если объект не
 * проинициализирован, провести инициализацию, поменять условие на «проинициализирован», снять блокировку и вернуть ссылку.
 *
 * Второй тест необходим, так как первая проверка может не означать, что объект не проинициализирован, например, если два
 * потока вошли в функцию одновременно. В этом случае оба потока получают статус «не проинициализирован», а затем один из них
 * берёт блокировку, а другой ожидает. Если не сделать дополнительную проверку, ожидающий поток на блокировке будет повторно
 * инициализировать объект.
 *
 */

int main()
{
    auto worker = []() -> void {
        Singleton::getInstance()->doSomething();
        ModernSingleton::getInstance().doSomething();
    };

    std::vector<std::thread> threads;

    for (int i = 0; i < 5; ++i)
    {
        threads.emplace_back(worker);
    }

    for (auto& t : threads)
    {
        t.join();
    }

    return 0;
}
